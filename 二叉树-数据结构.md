## **二叉树**

![二叉树 基本](https://124.71.203.87/md/BT.png)
拥有跟节点，每个节点有左右两个子节点，拥有子节点的元素称为**内部节点**，没有子节点的元素称为**叶子节点**。

### **二叉查找树（BST）**

![二叉树 基本](https://124.71.203.87/md/BST.png)
左侧几点小于父节点，右侧节点大于等于父节点。

![递归存储](https://124.71.203.87/md/recursion.png)

![中序遍历](https://124.71.203.87/md/inorderTraverNode.png)
![中序遍历](https://124.71.203.87/md/inorderTraverNodeTree.png)
![中序遍历执行流程图](https://124.71.203.87/md/inOrderTraverse.png)

![遍历顺序和推理](https://124.71.203.87/md/traverseReasoning.png)
![遍历顺序和推理](https://124.71.203.87/md/traverseReasoning2.png)

```
    let BST = (function () {
        class Node {
          constructor(data) {
            this.data = data;
            this.left = null;
            this.right = null;
          }
        }
        return class {
          constructor() {
            this.root = null;
          }
          insert(data) {
            if (!this.root) {
              this.root = new Node(data);
            } else {
              /**
               * 如果有root， 判断data是否大于root的data，大于则在root右边的节点作为新的root进行判断
               * 如果小于root的节点，则将root右边的节点作为新的节点进行判断。那什么时候停止呢？
               * 当找到一个节点，首先他的左节点或右节点为空，而data又恰好没被存储，且恰好大于或者小于当前节点的data
               * 那么这个空出来的相同方向的节点就是data的目标存储位置
               */
              this.insertRecursion(this.root, data);
            }
          }

          insertRecursion(root, data) {
            /**
             * 递归三部曲
             * 1. 确定递归的终止条件 向左递归，找到left为null；向右递归，找到right为null
             * 2. 确定递归的返回值
             * 3. 确定单层递归的逻辑
             */
            let direction = data < root.data ? "left" : "right"; // 判断向左递归还是向右递归
            if (!root[direction]) {
              root[direction] = new Node(data);
            } else {
              this.insertRecursion(root[direction], data);
            }
          }
          // 中序遍历 // 左根右
          inOrderTraverseNode(root = this.root, array = []) {
            /**
             * 期望遍历每棵树的 左 根 右 节点
             * 期望拿到整颗树的 左 根 右 节点 并返回记录节点顺序获得的数组 实现从小到大的排序
             * 什么时候终止？ 当root不为null的时候持续往下递达，并将root的左节点作为新的root进行递归，直到root为null时候，代表找到了最左边的叶子节点，
             * 也就是整颗树的最小值，所以把root和根节点push到数组，
             */
            if (root) {
              this.inOrderTraverseNode(root.left, array);
              array.push(root.data);
              this.inOrderTraverseNode(root.right, array);
            }
            return array;
          }
          // 后序遍历 // 左右根
          afterOrderTraverseNode(root = this.root, array = []) {
            if (root) {
              this.afterOrderTraverseNode(root.left, array);
              this.afterOrderTraverseNode(root.right, array);
              array.push(root.data);
            }
            return array;
          }
          // 前序遍历 // 根左右
          preOrderTraverseNode(root = this.root, array = []) {
            if (root) {
              array.push(root.data);
              this.preOrderTraverseNode(root.left, array);
              this.preOrderTraverseNode(root.right, array);
            }
            return array;
          }
        };
      })();
      let bst = new BST();
      bst.insert(20);
      bst.insert(10);
      bst.insert(30);
      bst.insert(5);
      bst.insert(9);
      bst.insert("a");
      console.log("a".charCodeAt(0));
      console.log("5".charCodeAt(0)); //ASCII number类型没有 ASCII 码
      console.log(bst.inOrderTraverseNode());
      console.log(bst.afterOrderTraverseNode());
      console.log(bst.preOrderTraverseNode());
      console.log(bst);
      /**
       * 1.二叉树
        已知：
        前序遍历：GDAFEMHZ
        中序遍历：ADEFGHMZ
        求：
        后续遍历
        2.二叉树
        已知：
        前序遍历：DABEGFC
        后序遍历：GFEBCAD
        求：
        中序遍历
       *
      */
```
