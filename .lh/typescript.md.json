{
    "sourceFile": "typescript.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746527181912,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746527181912,
            "name": "Commit-0",
            "content": "## **TypeScript**\n\n```\n// 全局安装\nnpm install -g typescript\ntsc --version\ntsc --init // 生成tsconfig.json\n// 局部安装\nnpm install typescript\nnpx tsc --version\n// 编译\ntsc hello.ts\n// 运行\nnode hello.js\n// 安装 编译+运行\nnpm i ts-node -g\n// 编译+运行\nts-node hello.ts\n\n/**\n* @param\n* @return\n*\n */\n```\n\n```\n// ts类型推断\nlet x = 10\nx+='1'\n```\n\n```\n// 数组类型\nlet f1: Array<number> = [1, 2, 3];\nlet f2: number[] = [1, 2, 3];\n```\n\n```\n// ts静态类型\nlet a: number = 1;\nlet b: string = \"hello\";\nlet c: boolean = true;\nlet d: any = \"world\";\nlet e: void = undefined;\nlet f: null = null;\nlet g: undefined = undefined;\n\n// 数组类型\nlet f1: Array<number> = [1, 2, 3];\nlet f2: number[] = [1, 2, 3];\n\nlet p: any[] = [\"张三\", 25];\np[1] = \"22\";\nconsole.log(p);\n\n// 元祖类型 数组第一位固定放字符串，第二位固定放数字\nlet z: [string, number] = [\"张三\", 25];\n// z[1] = '22'\n\n// 对象\nlet obj: { name: string; age: number } = {\n  name: \"张三\",\n  age: 25,\n};\n// 定义类型接口\ninterface Person {\n  name: string;\n  age: number;\n}\nlet obj2: Person = {\n  name: \"张三\",\n  age: 25,\n};\n\n// 枚举类型\nenum SEX {\n  MALE,\n  FEMALE,\n}\n/**\n *  枚举类型默认从0开始，依次递增\n *  枚举类型是普通对象，键名只能是 string｜number\n *  枚举类型可以双向取值，用属性值得到属性名，用属性名得到属性值\n */\n\nconsole.log(SEX.MALE);\nconsole.log(SEX.FEMALE);\nconsole.log(SEX[0]);\nconsole.log(SEX[1]);\n/*\n * 枚举类型可以手动赋值，以第一个为基数递增\n * 枚举类型第一个值如果是数字，后面的枚举值会自动递增\n * 如果给第二个赋值 之前的按初始值，之后的按当前递增\n * 如果给第二赋值不是数字，后面必须赋值，之前按默认初始值0递增\n */\nenum CORLOR {\n  RED,\n  GREEN = 100,\n  BLUE,\n}\nconsole.log(CORLOR.RED);\nconsole.log(CORLOR.GREEN);\nconsole.log(CORLOR.BLUE);\n\nenum COLOR2 {\n  RED,\n  GREEN = \"green\",\n  BLUE = \"blue\",\n}\nconsole.log(COLOR2.RED);\nconsole.log(COLOR2.GREEN);\nconsole.log(COLOR2.BLUE);\n\n// 函数类型\nfunction sum(x: number, y: number): number {\n  return x + y;\n}\nsum(1, 2);\n\nfunction sum2([a, b]: [number, number]) {\n  return a + b;\n}\nfunction sum3([a, b = 10]: number[]) {\n  return a + b;\n}\nfunction sum4([a, b]: Array<number>) {\n  return a + b;\n}\ninterface Sum {\n  (x: number, y: number): number;\n}\nfunction sum5({ a, b }): Sum {\n  return a + b;\n}\nfunction sum6(a: number, b: number, ...c: number[]): number {\n  return a * b + c.reduce((x: number, y: number) => x + y);\n}\ninterface Sum2 {\n  (a: number, b: number): number;\n}\nconst sum7 = (a, b): Sum2 => {\n  return a + b;\n};\nconst sum8 = (a: number): number => a;\nconst fu: Sum2 = (a, b) => a + b;\nconst fn: (a: number, b: number) => number = (x, y) => x + y;\ninterface Person2 {\n  a: number;\n  b: number;\n}\ninterface fnType {\n  (p: Person2): string;\n}\nlet fn2 = (p: Person2) => p.a + p.b + \"\";\nlet fn3: fnType = (p) => p.a + p.b + \"\";\nconsole.log(fn2({ a: 1, b: 2 }));\nconsole.log(fn(2, 3));\nconsole.log(sum7(2, 3));\nsum2([1, 2]);\nsum3([1]);\nsum6(1, 2, 3, 4, 5);\n\n// interface\ninterface Person3 {\n  name: string;\n  age?: number; // 可选属性 可有可无\n  id: number | string; // 联合类型 所有可以的类型\n  [propName: string]: any; // 任意属性 ke扩展属性\n  say(a: number): string; // 方法\n  fn?: fnType;\n}\nlet p1: Person3 = {\n  name: \"张三\",\n  age: 25,\n  id: \"123456\",\n  status: \"ok\",\n  sex: \"male\",\n  say() {\n    return \"hello\";\n  },\n};\nlet p2: Person3 = {\n  name: \"张三\",\n  id: 1,\n  111: 222,\n  say() {\n    return \"hello\";\n  },\n};\nlet id: number | string = 1;\nid = \"123456\";\n\n// 函数返回值 void 代表无返回值 never 代表永远不会有返回值\nlet ac = void 2; // undefined\nconsole.log(ac);\n\nlet ab = function (): never {\n  // 跑错之后永远不会return\n  throw new Error(\"error\");\n};\n// console.log(ab());\nlet ad = function (): void {\n  console.log(111);\n};\nconsole.log(ad());\n\ninterface T extends Person {\n  sex: string;\n  status: string;\n}\n\n// 联合类型\ninterface A {\n  name: string;\n}\ninterface B {\n  age: number;\n}\ntype C = A | B;\nlet we: C = {\n  name: \"张三\",\n  age: 25,\n};\ninterface D {\n  readonly name: string;\n  age: number;\n}\nlet wd2: D = {\n  name: \"张三\",\n  age: 25,\n};\n// wd2.name = \"李四\";\n// enum 扩展枚举\n// enum 不能直接继承或扩展，使用联合类型进行“逻辑上的扩展”\nenum Status {\n  Pending = \"Pending\",\n  Approved = \"Approved\",\n}\nenum Status2 {\n  name = \"Pending\",\n  age = \"Approved\",\n}\n// 合并为一个联合类型\ntype Status3 = Status | Status2;\nfunction handleStatus(status: Status3) {\n  console.log(status);\n}\nhandleStatus(Status.Pending);\n//使用常量对象代替 enum 并支持扩展\n//使用对象字面量 + as const\nconst BaseStatus = {\n  Pending: \"Pending\",\n  Approved: \"Approved\",\n} as const;\nconst Status4 = {\n  ...BaseStatus,\n  Rejected: \"Rejected\",\n};\ntype Status5 = (typeof BaseStatus)[keyof typeof BaseStatus];\nfunction handleStatus2(status: Status5) {\n  console.log(status);\n}\nhandleStatus2(BaseStatus.Pending);\n\n// 字面量类型 string｜number｜boolean｜bigint｜symbol\nlet df: \"ok\" = \"ok\";\nlet er: 20 = 20;\nlet ert: true = true;\nlet oo: \"男\" | \"女\" = \"男\";\n\n// type 定义类型别名\n// 联合类型 ｜\ntype SNB = string | number | boolean;\nlet ewr: SNB = 1;\ninterface Person4 {\n  name: string;\n  age: number;\n}\ninterface Person5 {\n  sex: string;\n  status: number;\n}\ntype Person6 = Person4 | Person5;\nlet per9: Person6 = {\n  name: \"张三\",\n  age: 25,\n  sex: \"string\",\n  status: 9,\n};\nconsole.log(per9);\n// & 交叉类型\ntype SNB2 = string & number; // 基础类型不能交叉\n// let ewr2: SNB2 = 1;\n// let arr: number[]&string[] = [1,2,\"3\"];\n// let arr: number[]｜string[] = [1,2,\"3\"];\ntype Person7 = Person4 & Person5;\nlet per10: Person7 = {\n  name: \"张三\",\n  age: 25,\n  sex: \"string\",\n  status: 9,\n};\nconsole.log(per10);\n\n// any 类型 告诉typescript 忽略类型检查\nlet et: any = \"32r23\";\nlet et2: number = 1;\n// et2 = et;\net = et2;\nconsole.log(et2, et);\n\n// unknown 类型 安全any\nlet wert: unknown = \"32r23\";\nlet wert2: number = 1;\n// wert2 = wert; // 不能将类型“unknown”分配给类型“number”。\n\n// 类型断言 <类型>值 或者 值 as 类型\nwert = 1111;\nwert2 = wert as number;\nwert = true;\nlet zz = <number>wert; // 类型断言会当前导致类型丢失，但是可以赋值给number\nconsole.log(zz);\nwert = 222;\n//使用类型判断更安全的使用 类型断言\nif (typeof wert === \"number\") {\n  //   wert2 = wert as number;\n  wert2 = <number>wert;\n}\nconsole.log(wert2, wert);\nwert = wert2; // 但是any类型可以赋值给unknown\n// console.log(wert2, wert);\ninterface Person8 {\n  name: string;\n}\n// 判断key isin object\nlet objqw: Person8 = {\n  name: \"张三\",\n};\n// 判断key是否存在\nif (\"name\" in objqw) {\n  console.log(obj[\"name\"]);\n}\n// 使用 instanceof 判断对象类型\nconsole.log(objqw instanceof Object); // true\n// 使用 Object.prototype.toString.call() 获取对象类型\nconsole.log(Object.prototype.toString.call(objqw)); // [object Object]\n// 在TypeScript中，可以使用类型断言来确认类型\nconsole.log((objqw as Person8).name); // 张三\n\n// 怎么获得interface 定义的具体类型\ninterface ss {\n  name: string;\n  age: number;\n\n  type: \"ss\";\n  [prop: string]: any; // 索引签名，允许任意属性名和值类型 [propName: string]\n}\nlet ss1: unknown = {\n  name: \"张三\",\n  age: 25,\n\n  type: \"ss\",\n};\n// 类型断言前判断类型\nif ((ss1 as ss).type === \"ss\") {\n  let ss2: ss = <ss>ss1;\n  console.log(ss2);\n}\n// 泛型\n// 把类型的定义推迟到使用时，在调用时传入具体类型\nfunction fne<T>(a: T): T {\n  // 三个T都表示同一种类型\n  return a;\n}\nfne(1);\nfne(\"1\");\nfne(true);\n\nfunction fne2<A>(a: A) {\n  return a;\n}\nfne2(1); // 推断为number\nfne2<string>(\"1\"); // 指定为string\nfne2<boolean>(true);\n// console.log(fne2<string>(true));\nfunction fmn<X, Y>(a: X, b: Y) {\n  return [a, b];\n}\nfmn<string, number>(\"1\", 2);\n\n// 泛型继承\ninterface L {\n  length: number;\n}\nfunction ddf<T extends L>(a: T) {\n  return a.length;\n}\nddf([\"123\", \"234\"]);\n// 泛型推断关系\n// 元泛型 入参类型推断 出参类型推断\nfunction ddf3<T>(a: T[]): T {\n  return a[0];\n}\nddf3<string>([\"123\", \"234\"]);\nddf3([\"123\", \"234\"]);\n\n// 函数类型定义\nlet fnwd: (a: number) => number = (a) => a + 1;\ninterface fnsdd {\n  (a: number): number;\n}\nlet fjs: fnsdd = (a) => a + 1;\nlet ergs: <T>(a: T) => T = (a) => a;\ninterface FH {\n  <T>(a: T): T;\n}\nlet ertwde: FH = (a) => a;\nconsole.log(ertwde(\"evev\"));\n```\n"
        }
    ]
}